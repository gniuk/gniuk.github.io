<!DOCTYPE html>
<html>
    <head>
        <title>Emacs align-regexp explained in detail with examples</title>
        <meta charset="utf-8"/>
        <meta name="tags" content="emacs, align, align-regexp"/>
        <meta name="date" content="2020-11-18 23:00:00"/>
        <meta name="modified" content="2020-11-19 17:30:00"/>
        <meta name="category" content="Emacs"/>
        <meta name="author" content="gniuk"/>
        <meta name="summary" content="Emacs align-regexp explained in detail with examples."/>
        <link href="../mycss/gniuk_style.css" rel="stylesheet" type="text/css">
        <link href="../../assets/css/custom.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <main>
            <h1>Emacs align-regexp explained in detail with examples</h1>
            <div class="authorline">
                By gniuk, isgniuk@gmail.com. Date:
                <time>2020-11-18</time>
                . Last updated:
                <time>2020-11-20</time>
                .
            </div>
            <p>
                Emacs comes with powerful and useful functions to align text to a specific column, by regexp.
            </p>
            <p>
                <strong>align</strong>
                is a simplified
                <strong>align-regexp</strong>
                with some predefined rules applying to current major mode. Sometimes it doesn't work well. So we focus on <strong>align-regexp</strong> here.
            </p>
            <h2>== Example ==</h2>
            <p>Take the following unreasonable code as an example.</p>
            <pre class="code-bg0">
#define    A    0x41
#define  WHAT_EVER  0x1BADB002
#define     ABCDE     0xabcde
            </pre>
            <p>We want it aligned as following.</p>
            <pre class="code-bg0">
#define A         0x41
#define WHAT_EVER 0x1BADB002
#define ABCDE     0xabcde
            </pre>
            <h2>== Howto ==</h2>
            <p>0. Recommended settings before start: (setq align-to-tab-stop nil)<kbd>C</kbd>-<kbd>x</kbd> <kbd>C</kbd>-<kbd>e</kbd>, if you want tabs treated the same as spaces. (defalias 'ar 'align-regexp)<kbd>C</kbd>-<kbd>x</kbd> <kbd>C</kbd>-<kbd>e</kbd> to help type align-regexp easily.</p>
            <p>1. Select the target lines.</p>
            <p>2. <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>, then choose
                <code class="parea">\(\s-*\)␣[A-Z]</code>,
                <code class="parea">1</code>,
                <code class="parea">0</code>,
                <code class="parea">n</code>
            </p>
            <p>3. Select again and: <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>, then choose
                <code class="parea">\(\s-*\)␣0</code>,
                <code class="parea">1</code>,
                <code class="parea">0</code>,
                <code class="parea">n</code>
            </p>
            <p>Or <i>the previous 2-3 two steps done in just one command:</i></p>
            <p><kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>, then choose
                <code class="parea">\(\s-*\)␣[A-Z0]</code>,
                <code class="parea">1</code>,
                <code class="parea">0</code>,
                <code class="parea">y</code>
            </p>
            <p><mark>Note</mark>: ␣ means exactly one space.</p>
            <h2>== Explain ==</h2>
            <p>First let's look at the function prototype of align-regexp.</p>
            <p><kbd>C</kbd>-<kbd>h</kbd> <kbd>f</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd></p>
            <p><code class="parea">(align-regexp BEG END REGEXP &optional GROUP SPACING REPEAT)</code></p>
            <p>When used interactively, this function need 4 args entered by the user in the minibuffer:</p>
            <ul>
                <li>REGEXP:&nbsp;&nbsp;<code class="parea"><mark><b>\(\s-*\) [A-Z]</b></mark>, 1, 0, n</code></li>
                <li>GROUP:&nbsp;&nbsp;&nbsp;<code class="parea">\(\s-*\) [A-Z], <mark><b>1</b></mark>, 0, n</code></li>
                <li>SPACING:<code class="parea">\(\s-*\) [A-Z], 1, <mark><b>0</b></mark>, n</code></li>
                <li>REPEAT:&nbsp;&nbsp;<code class="parea">\(\s-*\) [A-Z], 1, 0, <mark><b>n</b></mark></code></li>
            </ul>
            <p>REGEXP is the field matched to align with. The character need to be aligned is indicated by this REGEXP. Read on to find out how it works.</p>
            <p>In our example, the pattern <code class="parea">\(\s-*\)␣[A-Z]</code> matches the following fields:</p>
            <pre class="code-bg0">
#define<span class="boxed0"><span class="code-plain0">   </span><span class="code-plain1"> A</span></span>    0x41<br>
#define<span class="boxed0"><span class="code-plain0"> </span><span class="code-plain1"> W</span></span>HAT_EVER  0x1BADB002<br>
#define<span class="boxed0"><span class="code-plain0">    </span><span class="code-plain1"> A</span></span>BCDE     0xabcde
            </pre>
            <p>The subexpression <code class="parea">\(\s-*\)</code> is entered automatically by emacs when we invoke align-regexp with prefix args(i.e. C-u). The matched place in <code class="parea">\(\)</code> is where to insert or truncate characters to fulfill the alignment, and this is usually space field. <code class="parea">\s-</code> means whitespace(space or tab), same as <code class="parea">\s␣</code> and <code class="parea">␣</code>(if we have no tabs). <code class="parea">\s-*</code> means zero or more spaces.</p>
            <p>So <code class="parea">\(\s-*\)</code> matches the lighter background part(space field), and <code class="parea">␣[A-Z]</code> matches the darker part(a SPACE along with an UPPER character).</p>
            <p>
                Now let's talk about align. Align means <strong>make the first character exactly after the <code class="parea">\(\)</code> subexpression to be aligned at the same column as the others on the other lines</strong>.
                In our case, this character is the SPACE before the UPPER character. So we need these spaces on different lines aligned.
            </p>
            <p>
                The second arg GROUP is parenthesis group to modify. When invoked interatively there is usually exactly one parenthesis group <code class="parea">\(\)</code>. So just leave default value 1. In some case, we need this to be -1, we will talk about it later when we do a right-alignment.
            </p>
            <p>
                The third arg SPACING means the amount of spaces we want in the space field. In our case we need all the spaces in the parenthesis group to be deleted, so we provide 0.
            </p>
            <p>
                The fourth arg REPEAT means whether we want repeating the match and alignment. If we need exactly one match and alignment, then we provide n. When we use this pattern <code class="parea">\(\s-*\)␣[A-Z0]</code>, we provide y, because we need a second match and alignment for the <code class="parea">␣0x</code> part to be aligned.
            </p>
            <h2>== Get a deep understanding of \(\) ==</h2>
            <p>After understanding what \(\) means and how align works. We can now provide many pattern varients to get the alignments done. Here is an example:</p>
            <p>
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">\(\s-+\)[A-Z0]</code>,
                <code class="parea">1</code>,
                <code class="parea">1</code>,
                <code class="parea">y</code>
            </p>
            <p>Note there is no space between ) and [ this time. <code class="parea">\(\s-+\)</code> means 1 or more spaces. This REGEXP matches as following.</p>
            <pre class="code-bg0">
#define<span class="boxed0"><span class="code-plain0">    </span><span class="code-plain1">A</span></span><span class="boxed0"><span class="code-plain0">    </span><span class="code-plain1">0</span></span>x41<br>
#define<span class="boxed0"><span class="code-plain0">  </span><span class="code-plain1">W</span></span>HAT_EVER<span class="boxed0"><span class="code-plain0">  </span><span class="code-plain1">0</span></span>x1BADB002<br>
#define<span class="boxed0"><span class="code-plain0">     </span><span class="code-plain1">A</span></span>BCDE<span class="boxed0"><span class="code-plain0">     </span><span class="code-plain1">0</span></span>xabcde
            </pre>
            <p>The difference is the space field matched and the character chosen to be aligned. All spaces are now in the \(\) group, we need one space in the final result, so the third arg SPACING need to be 1 instead of 0. If you need more spaces just provide the value you want.</p>
            <h2>== Align to the right ==</h2>
            <p>Now let's talk about alignment to the right side.</p>
            Now we need the following alignment.
            <pre class="code-bg0">
#define         A 0x01
#define WHAT_EVER 0x1BADB002
#define     ABCDE 0xabcde
            </pre>
            <p>We do it like this:
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">\(\s-+[A-Z_]+\)</code>,
                <code class="parea">-1</code>,
                <code class="parea">1</code>,
                <code class="parea">n</code>
            </p>
            <p><code class="parea">\s-+</code> means 1 or more spaces, <code class="parea">[A-Z_]+</code> matches the UPPER and UPPER_WORD.</p>
            <p>So this matches the following(the lighter part):</p>
            <pre class="code-bg0">
#define<span class="boxed0"><span class="code-plain0">    A</span></span><span class="code-plain1"> </span>   0x41
#define<span class="boxed0"><span class="code-plain0">  WHAT_EVER</span></span><span class="code-plain1"> </span> 0x1BADB002
#define<span class="boxed0"><span class="code-plain0">     ABCDE</span></span><span class="code-plain1"> </span>     0xabcde
            </pre>
            <p>Now we set arg GROUP to -1 which means justify, according to the source code docs, justify means DO NOT delete non-space characters in the group and only insert or delete spaces in the initial spaces. <strong>The character after the last UPPER(the last char in \(\)) is chosen to be the alignment character</strong>, i.e. the space in darker background. Spaces are inserted or deleted before the first UPPER to fulfill the alignment. In this way we get right-alighment.
            </p>
            <p>
                We can match more characters before the \(\), <code class="parea">.*␣\(\s-*[A-Z_]+\)</code>, but this is not necessary in our case.
            </p>
            <h2>== More practice ==</h2>
            <p>①</p>
            <pre class="code-bg0">
struct stat64 {
        unsigned long long st_dev;      /* Device.  */
        unsigned long long st_ino;      /* File serial number.  */
        unsigned int    st_mode;        /* File mode.  */
        unsigned int    st_nlink;       /* Link count.  */
        unsigned int    st_uid;         /* User ID of the file's owner.  */
        unsigned int    st_gid;         /* Group ID of the file's group. */
        unsigned long long st_rdev;     /* Device number, if device.  */
        unsigned long long __pad1;
        long long       st_size;        /* Size of file, in bytes.  */
        int             st_blksize;     /* Optimal block size for I/O.  */
        int             __pad2;
        long long       st_blocks;      /* Number 512-byte blocks allocated. */
        int             st_atime;       /* Time of last access.  */
        unsigned int    st_atime_nsec;
        int             st_mtime;       /* Time of last modification.  */
        unsigned int    st_mtime_nsec;
        int             st_ctime;       /* Time of last status change.  */
        unsigned int    st_ctime_nsec;
        unsigned int    __unused4;
        unsigned int    __unused5;
};
            </pre>
            <p>Mark all the lines inside {} before aligh-regexp.</p>
            <p>
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">\(\s-*\)␣[s_]</code>,
                <code class="parea">1</code>,
                <code class="parea">0</code>,
                <code class="parea">n</code>
            </p>
            <p>
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">\(\s-*\)␣/</code>,
                <code class="parea">1</code>,
                <code class="parea">4</code>,
                <code class="parea">n</code>
            </p>
            <pre class="code-bg0">
struct stat64 {
        unsigned long long st_dev;         /* Device.  */
        unsigned long long st_ino;         /* File serial number.  */
        unsigned int       st_mode;        /* File mode.  */
        unsigned int       st_nlink;       /* Link count.  */
        unsigned int       st_uid;         /* User ID of the file's owner.  */
        unsigned int       st_gid;         /* Group ID of the file's group. */
        unsigned long long st_rdev;        /* Device number, if device.  */
        unsigned long long __pad1;
        long long          st_size;        /* Size of file, in bytes.  */
        int                st_blksize;     /* Optimal block size for I/O.  */
        int                __pad2;
        long long          st_blocks;      /* Number 512-byte blocks allocated. */
        int                st_atime;       /* Time of last access.  */
        unsigned int       st_atime_nsec;
        int                st_mtime;       /* Time of last modification.  */
        unsigned int       st_mtime_nsec;
        int                st_ctime;       /* Time of last status change.  */
        unsigned int       st_ctime_nsec;
        unsigned int       __unused4;
        unsigned int       __unused5;
};
            </pre>
            <p>----------------------------------------------------------------------------------------------------</p>
            <p>②</p>
            <pre class="code-bg0">
my @primes = (
    1,2,3,5,7,
    11,13,17,19,23,
    29,31,37,41,43,
);
            </pre>
            <p>
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">,\(\s-*\)[0-9]</code>,
                <code class="parea">1</code>,
                <code class="parea">1</code>,
                <code class="parea">y</code>
            </p>
            <pre class="code-bg0">
my @primes = (
    1,  2,  3,  5,  7,
    11, 13, 17, 19, 23,
    29, 31, 37, 41, 43,
);
            </pre>
            <p>
                <kbd>C</kbd>-<kbd>u</kbd> <kbd>M</kbd>-<kbd>x</kbd> <code class="elisp_defun">align-regexp</code> <kbd>RET</kbd>,
                <code class="parea">\([0-9]+,\)</code>,
                <code class="parea">-1</code>,
                <code class="parea">1</code>,
                <code class="parea">y</code>
            </p>
            <pre class="code-bg0">
my @primes = (
      1,  2,  3,  5,  7,
     11, 13, 17, 19, 23,
     29, 31, 37, 41, 43,
);
            </pre>
        </main>
    </body>
</html>
